# 암호코드
s = input()

N = len(s)
MOD = int(1e6)

# 예외처리
if s[0] == "0":  # 주의: 맨 앞이 0인 경우 해석불가
    print(0)
    exit()
elif N == 1:
    print(1)
    exit()

# dp[i]: i번째 글자까지 가능한 경우의 수
dp = [0] * N

# 초기화
dp[0] = 1
if s[1] != "0":
    dp[1] += 1
if 10 <= int(s[0:2]) <= 26:
    dp[1] += 1

# 점화식
for i in range(2, N):
    # Case 1. 한자리씩 읽기
    if s[i] != "0":
        dp[i] += dp[i - 1] % MOD
    # Case 2. 두자리씩 읽기
    if 10 <= int(s[i - 1 : i + 1]) <= 26:
        dp[i] += dp[i - 2] % MOD

print((dp[N - 1]) % MOD)

"""
- 난이도: 골드5
- 분류: dp
- 소요 시간: 50분 (풀이 30분, 디버깅 20분)

- 요약: 조건이 추가된 '계단 오르기' 유형

디버깅
1. 14% 틀렸습니다
    - 원인: '암호를 해석할 수 없는 경우', 즉 0에 주의할 것
2. 35% 틀렸습니다
    - 원인: 01을 넣었을때 답은 0인데 출력이 1이었던게 문제
    - 해결: 맨 앞에 0이 있으면 결과가 항상 0이 되도록 수정

최적화
- 생각해보면 2차원이 아니라 1차원으로도 해결 가능
"""
